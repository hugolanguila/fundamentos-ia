(load "mosaic-lib.lisp")

(defun rotar (mosaico grados)
  (append (nthcdr (- (length mosaico) grados) mosaico) (butlast mosaico grados)))

(defun rotar-mosaico (mosaico grados)
  (case grados
    (  0 mosaico)
    ( 60 (rotar mosaico 1))
    (120 (rotar mosaico 2))
    (180 (rotar mosaico 3))
    (240 (rotar mosaico 4))
    (300 (rotar mosaico 5))))

(defun lado-adyacente ( lado )
  (cond ((< lado 3)
	 (+ lado 3))
	((>= lado 3)
	 (- lado 3))))

(defun construir-tablero (piezas)
  (let ((tablero)
	(posicion)
	(mosaico))
    (dolist (pieza piezas tablero)
      (setq posicion (first pieza))
      (setq mosaico (get-piece-info (second pieza)))
      (setq mosaico (rotar-mosaico mosaico (third pieza)))
      (setq tablero (append tablero (list (list posicion mosaico)))))))

(defun estado-meta? ( piezas_colocadas )
  (let ((tablero nil)
	(posicion nil)
	(mosaico nil)
	(lista_adyacencia)
	(lado_adyacente)
	(mosaico_adyacente)
	(posicion_adyacente))
    (cond ((/= (length piezas_colocadas) 7) nil)
	  (T
	   (setq tablero (construir-tablero piezas_colocadas))
	   (format t "~%~%tablero: ~A~%~%" tablero)
	   (dolist (pieza tablero t)
	     (setq posicion (first pieza))
	     (setq mosaico (second pieza))
	     (setq lista_adyacencia (get-proximity-info posicion))
	     (dotimes (lado (length lista_adyacencia))
	       (cond ((null (nth lado lista_adyacencia)) nil)
		     (T
		      (setq lado_adyacente (lado-adyacente lado))
		      (setq posicion_adyacente (nth lado lista_adyacencia))
		      (setq mosaico_adyacente (second (nth posicion_adyacente tablero)))
		      (if (/= (nth lado mosaico) (nth lado_adyacente mosaico_adyacente))
			  (return-from estado-meta? nil))))))))))

(defparameter solucion '((1 F 120)
			 (2 H 180)
			 (3 E 60)
			 (4 A 0)
			 (5 B 300)
			 (6 D 300)
			 (7 C 0)))

(estado-meta? solucion)
